## Инструкция по запуску проекта

### Системные требования
- Python 3.11+
- Docker и docker-compose
- Poetry
- PostgreSQL (запускается через Docker)

### Установка
1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/ваш-username/test_task.git
   cd test_task
   ```

2. Настройте окружение:
   ```bash
    Обратите внимание на .env.example # Заполните переменные, если хотите с другими параметрами поднять instance
   ```

3. Установите зависимости:
   ```bash
   poetry install
   poetry shell
   ```

4. Запустите Docker:
   ```bash
   docker-compose up --build -d
   ```

### Запуск
1. Миграции будут применены через entrypoint.sh


2. Документация API:
   - Swagger: `http://localhost:8000/swagger/`
   - Админка: `http://localhost:8000/admin/`

---

### Архитектура
Проект реализован с использованием **чистой архитектуры**:
- `api/core/domain` — бизнес-логика и сущности
- `api/core/application` — сценарии использования
- `api/core/infrastructure` — адаптеры для БД

Альтернатива:  
Для простых проектов можно использовать подход с `services`, но текущая реализация обеспечивает:
- Независимость от фреймворков
- Легкую замену компонентов
- Удобное тестирование

---

### Тестирование (TODO)
Для будущей реализации я бы использовал:
- Интеграционные тесты с `APIClient`
- E2E тесты, также с использованием APIClient + поднятием тестовой бд через Django mark db.
- Юнит-тесты с мокированием репозиториев, также полноценный прогон функционала.

В рамках тестового задания я просто обозначил структуру тестов, а также указал на использование `APIClient`

---

### Структура проекта
```
test_task/
├── api/               # Контроллеры и DTO / Ядро (Clean Architecture)
├── credit_application # Модуль кредитных заявок, с реализованной логикой в api/core
```

Остальные модели были также реализованы, но логика CRUD была опущены в рамках тестового задания.

Docker написан по multistage build, также были пробросаны volumes для re-build контейнеров в локальной разработке ( удобство ).
Вся структура видна, если есть доп.вопросы, то всегда готов ответить на них.

В ci.yaml часть с тестами закомментирована, так как это показательный вариант на реальном проекте при CI/CD либо PullRequest.# test_project
